{"version":3,"file":"Clipboard.js","sources":["../../src/frontend/shared/Clipboard.ts"],"sourcesContent":["/**\n * Standalone Clipboard API\n * Works independently in any context: PWA, Chrome Extension, service worker, vanilla JS\n * Provides unified clipboard operations with fallbacks\n */\n\nexport type ClipboardDataType = \"text\" | \"html\" | \"image\" | \"blob\";\n\nexport interface ClipboardWriteOptions {\n    type?: ClipboardDataType;\n    mimeType?: string;\n    fallbackToLegacy?: boolean;\n    showFeedback?: boolean;\n    /** If true, don't show error toast on failure (for background operations) */\n    silentOnError?: boolean;\n}\n\nexport interface ClipboardResult {\n    ok: boolean;\n    data?: unknown;\n    error?: string;\n    method?: \"clipboard-api\" | \"legacy\" | \"broadcast\" | \"offscreen\";\n}\n\n// BroadcastChannel for cross-context clipboard operations\nconst CLIPBOARD_CHANNEL = \"rs-clipboard\";\n\n/**\n * Convert data to string safely\n */\nexport const toText = (data: unknown): string => {\n    if (data == null) return \"\";\n    if (typeof data === \"string\") return data;\n    try {\n        return JSON.stringify(data, null, 2);\n    } catch {\n        return String(data);\n    }\n};\n\n/**\n * Write text to clipboard using modern API\n */\nexport const writeText = async (text: string): Promise<ClipboardResult> => {\n    const trimmed = toText(text).trim();\n    if (!trimmed) return { ok: false, error: \"Empty content\" };\n\n    return new Promise<ClipboardResult>((resolve) => {\n        requestAnimationFrame(() => {\n            // Ensure document has focus for clipboard API\n            if (typeof document !== 'undefined' && document.hasFocus && !document.hasFocus()) {\n                window.focus();\n            }\n\n            // Try direct clipboard API first\n            const tryClipboardAPI = async () => {\n                try {\n                    if (typeof navigator !== \"undefined\" && navigator.clipboard?.writeText) {\n                        await navigator.clipboard.writeText(trimmed);\n                        return resolve({ ok: true, data: trimmed, method: \"clipboard-api\" });\n                    }\n                } catch (err) {\n                    console.warn(\"[Clipboard] Direct write failed:\", err);\n                }\n\n                // Try with permissions query\n                try {\n                    if (typeof navigator !== \"undefined\" && navigator.permissions) {\n                        const result = await navigator.permissions.query({ name: \"clipboard-write\" } as unknown as PermissionDescriptor);\n                        if (result.state === \"granted\" || result.state === \"prompt\") {\n                            await navigator.clipboard.writeText(trimmed);\n                            return resolve({ ok: true, data: trimmed, method: \"clipboard-api\" });\n                        }\n                    }\n                } catch (err) {\n                    console.warn(\"[Clipboard] Permission check failed:\", err);\n                }\n\n                // Fallback: legacy execCommand (deprecated but works in some contexts)\n                try {\n                    if (typeof document !== \"undefined\") {\n                        const textarea = document.createElement(\"textarea\");\n                        textarea.value = trimmed;\n                        textarea.style.cssText = \"position:fixed;left:-9999px;top:-9999px;opacity:0;pointer-events:none;\";\n                        document.body.appendChild(textarea);\n                        textarea.select();\n                        const success = document.execCommand(\"copy\");\n                        textarea.remove();\n                        if (success) {\n                            return resolve({ ok: true, data: trimmed, method: \"legacy\" });\n                        }\n                    }\n                } catch (err) {\n                    console.warn(\"[Clipboard] Legacy execCommand failed:\", err);\n                }\n\n                resolve({ ok: false, error: \"All clipboard methods failed\" });\n            };\n\n            tryClipboardAPI();\n        });\n    });\n};\n\n/**\n * Write HTML content to clipboard (with text fallback)\n */\nexport const writeHTML = async (html: string, plainText?: string): Promise<ClipboardResult> => {\n    const htmlContent = html.trim();\n    const textContent = (plainText ?? htmlContent).trim();\n\n    if (!htmlContent) return { ok: false, error: \"Empty content\" };\n\n    return new Promise<ClipboardResult>((resolve) => {\n        requestAnimationFrame(() => {\n            // Ensure document has focus for clipboard API\n            if (typeof document !== 'undefined' && document.hasFocus && !document.hasFocus()) {\n                window.focus();\n            }\n\n            const tryHTMLClipboard = async () => {\n                try {\n                    if (typeof navigator !== \"undefined\" && navigator.clipboard?.write) {\n                        const htmlBlob = new Blob([htmlContent], { type: \"text/html\" });\n                        const textBlob = new Blob([textContent], { type: \"text/plain\" });\n                        await navigator.clipboard.write([\n                            new ClipboardItem({\n                                \"text/html\": htmlBlob,\n                                \"text/plain\": textBlob\n                            })\n                        ]);\n                        return resolve({ ok: true, data: htmlContent, method: \"clipboard-api\" });\n                    }\n                } catch (err) {\n                    console.warn(\"[Clipboard] HTML write failed:\", err);\n                }\n\n                // Fallback to text-only\n                const textResult = await writeText(textContent);\n                resolve(textResult);\n            };\n\n            tryHTMLClipboard();\n        });\n    });\n};\n\n/**\n * Write image to clipboard\n */\nexport const writeImage = async (blob: Blob | string): Promise<ClipboardResult> => {\n    return new Promise<ClipboardResult>((resolve) => {\n        requestAnimationFrame(async () => {\n            // Ensure document has focus for clipboard API\n            if (typeof document !== 'undefined' && document.hasFocus && !document.hasFocus()) {\n                window.focus();\n            }\n\n            try {\n                let imageBlob: Blob;\n\n                if (typeof blob === \"string\") {\n                    // Convert data URL or URL to blob\n                    if (blob.startsWith(\"data:\")) {\n                        const response = await fetch(blob);\n                        imageBlob = await response.blob();\n                    } else {\n                        const response = await fetch(blob);\n                        imageBlob = await response.blob();\n                    }\n                } else {\n                    imageBlob = blob;\n                }\n\n                if (typeof navigator !== \"undefined\" && navigator.clipboard?.write) {\n                    // Ensure PNG format for clipboard compatibility\n                    const pngBlob = imageBlob.type === \"image/png\"\n                        ? imageBlob\n                        : await convertToPng(imageBlob);\n\n                    await navigator.clipboard.write([\n                        new ClipboardItem({\n                            [pngBlob.type]: pngBlob\n                        })\n                    ]);\n                    resolve({ ok: true, method: \"clipboard-api\" });\n                    return;\n                }\n            } catch (err) {\n                console.warn(\"[Clipboard] Image write failed:\", err);\n            }\n\n            resolve({ ok: false, error: \"Image clipboard not supported\" });\n        });\n    });\n};\n\n/**\n * Convert image blob to PNG\n */\nconst convertToPng = async (blob: Blob): Promise<Blob> => {\n    return new Promise((resolve, reject) => {\n        if (typeof document === \"undefined\") {\n            reject(new Error(\"No document context\"));\n            return;\n        }\n\n        const img = new Image();\n        const url = URL.createObjectURL(blob);\n\n        img.onload = () => {\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = img.naturalWidth;\n            canvas.height = img.naturalHeight;\n\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                URL.revokeObjectURL(url);\n                reject(new Error(\"Canvas context failed\"));\n                return;\n            }\n\n            ctx.drawImage(img, 0, 0);\n            canvas.toBlob(\n                (pngBlob) => {\n                    URL.revokeObjectURL(url);\n                    if (pngBlob) {\n                        resolve(pngBlob);\n                    } else {\n                        reject(new Error(\"PNG conversion failed\"));\n                    }\n                },\n                \"image/png\"\n            );\n        };\n\n        img.onerror = () => {\n            URL.revokeObjectURL(url);\n            reject(new Error(\"Image load failed\"));\n        };\n\n        img.src = url;\n    });\n};\n\n/**\n * Read text from clipboard\n */\nexport const readText = async (): Promise<ClipboardResult> => {\n    return new Promise<ClipboardResult>((resolve) => {\n        requestAnimationFrame(() => {\n            const tryReadClipboard = async () => {\n                try {\n                    if (typeof navigator !== \"undefined\" && navigator.clipboard?.readText) {\n                        const text = await navigator.clipboard.readText();\n                        resolve({ ok: true, data: text, method: \"clipboard-api\" });\n                        return;\n                    }\n                } catch (err) {\n                    console.warn(\"[Clipboard] Read failed:\", err);\n                }\n\n                resolve({ ok: false, error: \"Clipboard read not available\" });\n            };\n\n            tryReadClipboard();\n        });\n    });\n};\n\n/**\n * Unified copy function with automatic type detection\n */\nexport const copy = async (\n    data: unknown,\n    options: ClipboardWriteOptions = {}\n): Promise<ClipboardResult> => {\n    const { type, showFeedback = false, silentOnError = false } = options;\n\n    return new Promise<ClipboardResult>((resolve) => {\n        requestAnimationFrame(async () => {\n            let result: ClipboardResult;\n\n            // Determine type and copy\n            if (data instanceof Blob) {\n                if (data.type.startsWith(\"image/\")) {\n                    result = await writeImage(data);\n                } else {\n                    const text = await data.text();\n                    result = await writeText(text);\n                }\n            } else if (type === \"html\" || (typeof data === \"string\" && data.trim().startsWith(\"<\"))) {\n                result = await writeHTML(String(data));\n            } else if (type === \"image\") {\n                result = await writeImage(data as Blob | string);\n            } else {\n                result = await writeText(toText(data));\n            }\n\n            // Optionally show feedback via toast broadcast\n            // Skip error toast if silentOnError is true (e.g., background clipboard operations)\n            if (showFeedback && (result.ok || !silentOnError)) {\n                broadcastClipboardFeedback(result);\n            }\n\n            resolve(result);\n        });\n    });\n};\n\n/**\n * Broadcast clipboard feedback for toast display\n */\nconst broadcastClipboardFeedback = (result: ClipboardResult): void => {\n    try {\n        const channel = new BroadcastChannel(\"rs-toast\");\n        channel.postMessage({\n            type: \"show-toast\",\n            options: {\n                message: result.ok ? \"Copied to clipboard\" : (result.error || \"Copy failed\"),\n                kind: result.ok ? \"success\" : \"error\",\n                duration: 2000\n            }\n        });\n        channel.close();\n    } catch (e) {\n        console.warn(\"[Clipboard] Feedback broadcast failed:\", e);\n    }\n};\n\n/**\n * Request clipboard operation via broadcast (for service worker → client)\n */\nexport const requestCopy = (data: unknown, options?: ClipboardWriteOptions): void => {\n    try {\n        const channel = new BroadcastChannel(CLIPBOARD_CHANNEL);\n        channel.postMessage({ type: \"copy\", data, options });\n        channel.close();\n    } catch (e) {\n        console.warn(\"[Clipboard] Request broadcast failed:\", e);\n    }\n};\n\n/**\n * Listen for clipboard operation requests\n */\nexport const listenForClipboardRequests = (): (() => void) => {\n    if (typeof BroadcastChannel === \"undefined\") return () => {};\n\n    const channel = new BroadcastChannel(CLIPBOARD_CHANNEL);\n    const handler = async (event: MessageEvent) => {\n        if (event.data?.type === \"copy\") {\n            const opts = event.data.options || {};\n            await copy(event.data.data, {\n                ...opts,\n                showFeedback: opts.showFeedback !== false,\n                silentOnError: opts.silentOnError === true\n            });\n        }\n    };\n    channel.addEventListener(\"message\", handler);\n    return () => {\n        channel.removeEventListener(\"message\", handler);\n        channel.close();\n    };\n};\n\n/**\n * Initialize clipboard listener for receiving copy requests\n */\nexport const initClipboardReceiver = (): (() => void) => {\n    return listenForClipboardRequests();\n};\n\n/**\n * Check if clipboard API is available\n */\nexport const isClipboardAvailable = (): boolean => {\n    return typeof navigator !== \"undefined\" && !!navigator.clipboard;\n};\n\n/**\n * Check if clipboard write is available\n */\nexport const isClipboardWriteAvailable = (): boolean => {\n    return typeof navigator !== \"undefined\" && typeof navigator.clipboard?.writeText === \"function\";\n};\n\n/**\n * Check if running in Chrome extension context\n */\nexport const isChromeExtension = (): boolean => {\n    try {\n        return typeof chrome !== \"undefined\" && !!chrome?.runtime?.id;\n    } catch {\n        return false;\n    }\n};\n\nexport interface CRXCopyOptions {\n    tabId?: number;\n    /** Optional fallback function for offscreen document copy */\n    offscreenFallback?: (data: unknown) => Promise<boolean>;\n}\n\n/**\n * Request copy via Chrome extension message (for CRX service worker → content script)\n * Falls back to offscreen document or BroadcastChannel if content script fails\n */\nexport const requestCopyViaCRX = async (\n    data: unknown,\n    tabIdOrOptions?: number | CRXCopyOptions\n): Promise<ClipboardResult> => {\n    const options: CRXCopyOptions = typeof tabIdOrOptions === \"number\"\n        ? { tabId: tabIdOrOptions }\n        : (tabIdOrOptions || {});\n\n    const { tabId, offscreenFallback } = options;\n    const text = toText(data).trim();\n    if (!text) return { ok: false, error: \"Empty content\" };\n\n    // If in extension context with tabs API\n    if (isChromeExtension() && typeof chrome?.tabs?.sendMessage === \"function\") {\n        try {\n            // Send to specific tab or active tab\n            if (typeof tabId === \"number\" && tabId >= 0) {\n                const response = await chrome.tabs.sendMessage(tabId, {\n                    type: \"COPY_HACK\",\n                    data: text\n                });\n                if (response?.ok) {\n                    return {\n                        ok: true,\n                        data: response?.data,\n                        method: response?.method ?? \"broadcast\"\n                    };\n                }\n            } else {\n                // Query active tab\n                const tabs = await chrome.tabs.query({ currentWindow: true, active: true });\n                for (const tab of tabs || []) {\n                    if (tab?.id != null && tab.id >= 0) {\n                        try {\n                            const response = await chrome.tabs.sendMessage(tab.id, {\n                                type: \"COPY_HACK\",\n                                data: text\n                            });\n                            if (response?.ok) {\n                                return {\n                                    ok: true,\n                                    data: response?.data,\n                                    method: response?.method ?? \"broadcast\"\n                                };\n                            }\n                        } catch {\n                            // Tab may not have content script, continue to next\n                        }\n                    }\n                }\n            }\n        } catch (err) {\n            console.warn(\"[Clipboard] CRX content script message failed:\", err);\n        }\n\n        // Fallback to offscreen document if provided\n        if (offscreenFallback) {\n            try {\n                const ok = await offscreenFallback(text);\n                if (ok) {\n                    return { ok: true, data: text, method: \"offscreen\" };\n                }\n            } catch (err) {\n                console.warn(\"[Clipboard] Offscreen fallback failed:\", err);\n            }\n        }\n    }\n\n    // Final fallback to BroadcastChannel\n    requestCopy(data, { showFeedback: true });\n    return { ok: false, error: \"Broadcast sent, result pending\", method: \"broadcast\" };\n};\n\n/**\n * COPY_HACK - Legacy API for Chrome extension clipboard operations\n * Now delegates to unified Clipboard module\n */\nexport const COPY_HACK = async (data: unknown): Promise<boolean> => {\n    const result = await writeText(toText(data));\n    return result.ok;\n};\n\n/**\n * Copy with result - returns full ClipboardResult for more control\n */\nexport const copyWithResult = async (data: unknown): Promise<ClipboardResult> => {\n    return writeText(toText(data));\n};\n\n\n// Default export for convenience\nexport default {\n    copy,\n    writeText,\n    writeHTML,\n    writeImage,\n    readText,\n    toText,\n    request: requestCopy,\n    requestViaCRX: requestCopyViaCRX,\n    listen: listenForClipboardRequests,\n    init: initClipboardReceiver,\n    isAvailable: isClipboardAvailable,\n    isWriteAvailable: isClipboardWriteAvailable,\n    isChromeExtension\n};\n\n"],"names":[],"mappings":"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"}