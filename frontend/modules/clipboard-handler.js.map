{"version":3,"mappings":"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","names":["result"],"ignoreList":[],"sources":["../../src/crx/shared/clipboard-handler.ts"],"sourcesContent":["/**\n * Unified CRX Clipboard Handler\n * Works in both content script and offscreen document contexts\n * Auto-detects context and handles messages appropriately\n */\n\nimport { writeText, toText } from \"@rs-frontend/shared/Clipboard\";\n\nexport type CopyResponse = {\n    ok: boolean;\n    data?: string;\n    method?: string;\n    error?: string;\n};\n\nexport type CRXClipboardContext = \"content\" | \"offscreen\" | \"unknown\";\n\n/**\n * Get the best available timing function for scheduling callbacks\n * Prefers requestAnimationFrame when available, falls back to setTimeout\n */\nexport const getTimingFunction = (): ((callback: () => void) => void) => {\n    if (typeof requestAnimationFrame !== 'undefined') {\n        return requestAnimationFrame;\n    }\n    if (typeof setTimeout !== 'undefined') {\n        return (cb) => setTimeout(cb, 0);\n    }\n    // Last resort: execute immediately\n    return (cb) => cb();\n};\n\n/**\n * Detect current CRX context\n */\nexport const detectContext = (): CRXClipboardContext => {\n    try {\n        // Offscreen documents have limited APIs and specific URL pattern\n        if (typeof location !== \"undefined\" && location.href.includes(\"offscreen\")) {\n            return \"offscreen\";\n        }\n        // Content scripts have access to the page DOM\n        if (typeof document !== \"undefined\" && document.body) {\n            return \"content\";\n        }\n    } catch {\n        // Ignore errors in context detection\n    }\n    return \"unknown\";\n};\n\n/**\n * Show toast feedback (only works in content script context)\n */\nconst showFeedback = async (message: string): Promise<void> => {\n    try {\n        // Dynamic import to avoid bundling overlay in offscreen\n        const { showToast } = await import(\"@rs-frontend/shared/overlay\");\n        showToast(message);\n    } catch {\n        console.log(\"[Clipboard]\", message);\n    }\n};\n\n/**\n * Enhanced clipboard write with RAF timing and multiple retries\n */\nconst writeTextWithRAF = async (text: string, maxRetries = 3): Promise<{ ok: boolean; method?: string; error?: string }> => {\n    const trimmed = text.trim();\n    if (!trimmed) return { ok: false, error: \"Empty content\" };\n\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n        try {\n            // Use RAF for proper timing, fallback to setTimeout for service workers\n            const result = await new Promise<{ ok: boolean; method?: string; error?: string }>((resolve) => {\n                const timerFn = getTimingFunction();\n                timerFn(() => {\n                    // Ensure document has focus for clipboard API (if in content script)\n                    if (detectContext() === \"content\" && typeof document !== 'undefined' && document.hasFocus && !document.hasFocus()) {\n                        try {\n                            window.focus();\n                        } catch {\n                            // Ignore focus errors\n                        }\n                    }\n\n                    // Try direct clipboard API first\n                    const tryClipboardAPI = async () => {\n                        try {\n                            if (typeof navigator !== \"undefined\" && navigator.clipboard?.writeText) {\n                                await navigator.clipboard.writeText(trimmed);\n                                return resolve({ ok: true, method: \"clipboard-api\" });\n                            }\n                        } catch (err) {\n                            console.warn(`[Clipboard] Direct write failed (attempt ${attempt + 1}):`, err);\n                        }\n\n                        // Try with permissions query (Chrome extension specific)\n                        try {\n                            if (typeof navigator !== \"undefined\" && navigator.permissions) {\n                                const result = await navigator.permissions.query({ name: \"clipboard-write\" } as unknown as PermissionDescriptor);\n                                if (result.state === \"granted\" || result.state === \"prompt\") {\n                                    await navigator.clipboard.writeText(trimmed);\n                                    return resolve({ ok: true, method: \"clipboard-api-permission\" });\n                                }\n                            }\n                        } catch (err) {\n                            console.warn(`[Clipboard] Permission check failed (attempt ${attempt + 1}):`, err);\n                        }\n\n                        // Fallback: legacy execCommand (works in content scripts)\n                        try {\n                            if (detectContext() === \"content\" && typeof document !== \"undefined\") {\n                                const textarea = document.createElement(\"textarea\");\n                                textarea.value = trimmed;\n                                textarea.style.cssText = \"position:fixed;left:-9999px;top:-9999px;opacity:0;pointer-events:none;z-index:-1;\";\n                                document.body.appendChild(textarea);\n                                textarea.select();\n\n                                // Focus the textarea for better compatibility\n                                textarea.focus();\n\n                                const success = document.execCommand(\"copy\");\n                                textarea.remove();\n\n                                if (success) {\n                                    return resolve({ ok: true, method: \"legacy-execCommand\" });\n                                }\n                            }\n                        } catch (err) {\n                            console.warn(`[Clipboard] Legacy execCommand failed (attempt ${attempt + 1}):`, err);\n                        }\n\n                        // Additional fallback: try again after a short delay\n                        if (attempt < maxRetries - 1) {\n                            setTimeout(() => tryClipboardAPI(), 100);\n                            return;\n                        }\n\n                        resolve({ ok: false, error: \"All clipboard methods failed\" });\n                    };\n\n                    tryClipboardAPI();\n                });\n            });\n\n            if (result.ok) {\n                return result;\n            }\n\n            // If this attempt failed and we have retries left, wait before next attempt\n            if (attempt < maxRetries - 1) {\n                await new Promise(resolve => setTimeout(resolve, 200 * (attempt + 1)));\n            }\n\n        } catch (error) {\n            console.warn(`[Clipboard] Attempt ${attempt + 1} completely failed:`, error);\n            if (attempt < maxRetries - 1) {\n                await new Promise(resolve => setTimeout(resolve, 200 * (attempt + 1)));\n            }\n        }\n    }\n\n    return { ok: false, error: `Failed after ${maxRetries} attempts` };\n};\n\n/**\n * Handle clipboard copy request with enhanced stability\n */\nexport const handleCopyRequest = async (\n    data: unknown,\n    options: { showFeedback?: boolean; errorMessage?: string; maxRetries?: number } = {}\n): Promise<CopyResponse> => {\n    const text = toText(data).trim();\n    const { maxRetries = 3 } = options;\n\n    if (!text) {\n        return { ok: false, error: \"Empty content\" };\n    }\n\n    console.log(`[Clipboard] Attempting to copy ${text.length} characters (${detectContext()})`);\n\n    const result = await writeTextWithRAF(text, maxRetries);\n\n    console.log(`[Clipboard] Copy result:`, result);\n\n    // Show feedback if requested and in appropriate context\n    if (options.showFeedback && detectContext() === \"content\") {\n        if (result.ok) {\n            await showFeedback(\"Copied to clipboard\");\n        } else {\n            await showFeedback(options.errorMessage || result.error || \"Failed to copy\");\n        }\n    }\n\n    return {\n        ok: result.ok,\n        data: text,\n        method: result.method || detectContext(),\n        error: result.error\n    };\n};\n\nlet _handlerRegistered = false;\n\n/**\n * Initialize COPY_HACK message handler\n * Auto-configures based on detected context\n */\nexport const initClipboardHandler = (\n    options: {\n        /** Only respond to messages with target matching this value */\n        targetFilter?: string;\n        /** Show toast feedback on copy */\n        showFeedback?: boolean;\n    } = {}\n): void => {\n    if (_handlerRegistered) return;\n    _handlerRegistered = true;\n\n    const context = detectContext();\n    const { targetFilter, showFeedback: feedback = context === \"content\" } = options;\n\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        console.log(`[Clipboard] Received message:`, message, `from:`, sender);\n\n        // Filter by target if specified\n        if (targetFilter && message?.target !== targetFilter) {\n            console.log(`[Clipboard] Message filtered out by target:`, message?.target, `expected:`, targetFilter);\n            return false;\n        }\n\n        // Handle COPY_HACK messages\n        if (message?.type === \"COPY_HACK\") {\n            console.log(`[Clipboard] Processing COPY_HACK message with data:`, message?.data?.substring?.(0, 50) + '...');\n            handleCopyRequest(message?.data, {\n                showFeedback: feedback,\n                errorMessage: message?.error\n            }).then(response => {\n                console.log(`[Clipboard] COPY_HACK response:`, response);\n                sendResponse(response);\n            }).catch(error => {\n                console.error(`[Clipboard] COPY_HACK error:`, error);\n                sendResponse({ ok: false, error: String(error) });\n            });\n            return true; // async response\n        }\n\n        return false;\n    });\n\n    console.log(`[Clipboard] Handler initialized (${context})`);\n};\n\n// Re-export for convenience\nexport { writeText, toText } from \"@rs-frontend/shared/Clipboard\";\n\n"],"file":"clipboard-handler.js"}